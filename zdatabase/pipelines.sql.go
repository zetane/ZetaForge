// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: pipelines.sql

package zdatabase

import (
	"context"
	"database/sql"
)

const allFilterPipelines = `-- name: AllFilterPipelines :many
SELECT p.id, p.organization, p.created, p.uuid, p.hash, p.json, p.deployed, p.deleted, e.id, e.pipeline, e.status, e.created, e.completed, e.json, e.deleted, e.executionid, e.workflow, e.results FROM Pipelines p
INNER JOIN Executions e on e.pipeline = p.id
WHERE e.status != 'pending' AND e.workflow is not null and p.deleted = FALSE
ORDER BY e.created DESC
`

type AllFilterPipelinesRow struct {
	ID           int64
	Organization string
	Created      int64
	Uuid         string
	Hash         string
	Json         string
	Deployed     int64
	Deleted      int64
	ID_2         int64
	Pipeline     int64
	Status       interface{}
	Created_2    int64
	Completed    sql.NullInt64
	Json_2       sql.NullString
	Deleted_2    int64
	Executionid  string
	Workflow     sql.NullString
	Results      sql.NullString
}

func (q *Queries) AllFilterPipelines(ctx context.Context) ([]AllFilterPipelinesRow, error) {
	rows, err := q.db.QueryContext(ctx, allFilterPipelines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AllFilterPipelinesRow
	for rows.Next() {
		var i AllFilterPipelinesRow
		if err := rows.Scan(
			&i.ID,
			&i.Organization,
			&i.Created,
			&i.Uuid,
			&i.Hash,
			&i.Json,
			&i.Deployed,
			&i.Deleted,
			&i.ID_2,
			&i.Pipeline,
			&i.Status,
			&i.Created_2,
			&i.Completed,
			&i.Json_2,
			&i.Deleted_2,
			&i.Executionid,
			&i.Workflow,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO Pipelines(
	organization, created, uuid, hash, json
) VALUES (
	?, unixepoch('now'), ?, ?, json(?)
)
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type CreatePipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
	Json         interface{}
}

func (q *Queries) CreatePipeline(ctx context.Context, arg CreatePipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, createPipeline,
		arg.Organization,
		arg.Uuid,
		arg.Hash,
		arg.Json,
	)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const deployPipeline = `-- name: DeployPipeline :one
UPDATE Pipelines
SET deployed = TRUE
WHERE organization = ? AND uuid = ? AND hash = ?
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type DeployPipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
}

func (q *Queries) DeployPipeline(ctx context.Context, arg DeployPipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, deployPipeline, arg.Organization, arg.Uuid, arg.Hash)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const filterPipeline = `-- name: FilterPipeline :one
SELECT p.id, p.organization, p.created, p.uuid, p.hash, p.json, p.deployed, p.deleted, e.id, e.pipeline, e.status, e.created, e.completed, e.json, e.deleted, e.executionid, e.workflow, e.results FROM Pipelines p
INNER JOIN Executions e on e.pipeline = p.id
WHERE e.executionid = ?
ORDER BY e.created DESC
`

type FilterPipelineRow struct {
	ID           int64
	Organization string
	Created      int64
	Uuid         string
	Hash         string
	Json         string
	Deployed     int64
	Deleted      int64
	ID_2         int64
	Pipeline     int64
	Status       interface{}
	Created_2    int64
	Completed    sql.NullInt64
	Json_2       sql.NullString
	Deleted_2    int64
	Executionid  string
	Workflow     sql.NullString
	Results      sql.NullString
}

func (q *Queries) FilterPipeline(ctx context.Context, executionid string) (FilterPipelineRow, error) {
	row := q.db.QueryRowContext(ctx, filterPipeline, executionid)
	var i FilterPipelineRow
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
		&i.ID_2,
		&i.Pipeline,
		&i.Status,
		&i.Created_2,
		&i.Completed,
		&i.Json_2,
		&i.Deleted_2,
		&i.Executionid,
		&i.Workflow,
		&i.Results,
	)
	return i, err
}

const filterPipelines = `-- name: FilterPipelines :many
SELECT p.id, p.organization, p.created, p.uuid, p.hash, p.json, p.deployed, p.deleted, e.id, e.pipeline, e.status, e.created, e.completed, e.json, e.deleted, e.executionid, e.workflow, e.results FROM Pipelines p
INNER JOIN Executions e on e.pipeline = p.id
WHERE e.status != 'pending' AND e.workflow is not null and p.deleted = FALSE
ORDER BY e.created DESC
LIMIT ? OFFSET ?
`

type FilterPipelinesParams struct {
	Limit  int64
	Offset int64
}

type FilterPipelinesRow struct {
	ID           int64
	Organization string
	Created      int64
	Uuid         string
	Hash         string
	Json         string
	Deployed     int64
	Deleted      int64
	ID_2         int64
	Pipeline     int64
	Status       interface{}
	Created_2    int64
	Completed    sql.NullInt64
	Json_2       sql.NullString
	Deleted_2    int64
	Executionid  string
	Workflow     sql.NullString
	Results      sql.NullString
}

func (q *Queries) FilterPipelines(ctx context.Context, arg FilterPipelinesParams) ([]FilterPipelinesRow, error) {
	rows, err := q.db.QueryContext(ctx, filterPipelines, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterPipelinesRow
	for rows.Next() {
		var i FilterPipelinesRow
		if err := rows.Scan(
			&i.ID,
			&i.Organization,
			&i.Created,
			&i.Uuid,
			&i.Hash,
			&i.Json,
			&i.Deployed,
			&i.Deleted,
			&i.ID_2,
			&i.Pipeline,
			&i.Status,
			&i.Created_2,
			&i.Completed,
			&i.Json_2,
			&i.Deleted_2,
			&i.Executionid,
			&i.Workflow,
			&i.Results,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPipeline = `-- name: GetPipeline :one
SELECT id, organization, created, uuid, hash, json, deployed, deleted FROM Pipelines
WHERE organization = ? AND uuid = ? AND hash = ? AND deleted = FALSE
`

type GetPipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
}

func (q *Queries) GetPipeline(ctx context.Context, arg GetPipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, getPipeline, arg.Organization, arg.Uuid, arg.Hash)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const listAllPipelines = `-- name: ListAllPipelines :many
SELECT id, organization, created, uuid, hash, json, deployed, deleted FROM Pipelines
WHERE organization = ? AND deleted = FALSE
ORDER BY deployed DESC, created DESC
`

func (q *Queries) ListAllPipelines(ctx context.Context, organization string) ([]Pipeline, error) {
	rows, err := q.db.QueryContext(ctx, listAllPipelines, organization)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pipeline
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.Organization,
			&i.Created,
			&i.Uuid,
			&i.Hash,
			&i.Json,
			&i.Deployed,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelines = `-- name: ListPipelines :many
SELECT id, organization, created, uuid, hash, json, deployed, deleted FROM Pipelines
WHERE organization = ? AND uuid = ? AND deleted = FALSE
ORDER BY deployed DESC, created DESC
`

type ListPipelinesParams struct {
	Organization string
	Uuid         string
}

func (q *Queries) ListPipelines(ctx context.Context, arg ListPipelinesParams) ([]Pipeline, error) {
	rows, err := q.db.QueryContext(ctx, listPipelines, arg.Organization, arg.Uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pipeline
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.Organization,
			&i.Created,
			&i.Uuid,
			&i.Hash,
			&i.Json,
			&i.Deployed,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeletePipeline = `-- name: SoftDeletePipeline :one
UPDATE Pipelines
SET deleted = TRUE, deployed = FALSE
WHERE organization = ? AND uuid = ? AND hash = ?
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type SoftDeletePipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
}

func (q *Queries) SoftDeletePipeline(ctx context.Context, arg SoftDeletePipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, softDeletePipeline, arg.Organization, arg.Uuid, arg.Hash)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const undeployPipeline = `-- name: UndeployPipeline :one
UPDATE Pipelines
SET deployed = FALSE
WHERE organization = ? AND uuid = ? AND deployed = TRUE
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type UndeployPipelineParams struct {
	Organization string
	Uuid         string
}

func (q *Queries) UndeployPipeline(ctx context.Context, arg UndeployPipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, undeployPipeline, arg.Organization, arg.Uuid)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

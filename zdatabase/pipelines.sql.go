// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: pipelines.sql

package zdatabase

import (
	"context"
)

const createPipeline = `-- name: CreatePipeline :one
INSERT INTO Pipelines(
	organization, created, uuid, hash, json
) VALUES (
	?, unixepoch('now'), ?, ?, json(?)
)
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type CreatePipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
	Json         interface{}
}

func (q *Queries) CreatePipeline(ctx context.Context, arg CreatePipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, createPipeline,
		arg.Organization,
		arg.Uuid,
		arg.Hash,
		arg.Json,
	)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const deployPipeline = `-- name: DeployPipeline :one
UPDATE Pipelines
SET deployed = TRUE
WHERE organization = ? AND uuid = ? AND hash = ? 
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type DeployPipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
}

func (q *Queries) DeployPipeline(ctx context.Context, arg DeployPipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, deployPipeline, arg.Organization, arg.Uuid, arg.Hash)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const getPipeline = `-- name: GetPipeline :one
SELECT id, organization, created, uuid, hash, json, deployed, deleted FROM Pipelines
WHERE organization = ? AND uuid = ? AND hash = ? AND deleted = FALSE
`

type GetPipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
}

func (q *Queries) GetPipeline(ctx context.Context, arg GetPipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, getPipeline, arg.Organization, arg.Uuid, arg.Hash)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const listAllPipelines = `-- name: ListAllPipelines :many
SELECT id, organization, created, uuid, hash, json, deployed, deleted FROM Pipelines
WHERE organization = ? AND deleted = FALSE
ORDER BY deployed DESC, created DESC
`

func (q *Queries) ListAllPipelines(ctx context.Context, organization string) ([]Pipeline, error) {
	rows, err := q.db.QueryContext(ctx, listAllPipelines, organization)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pipeline
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.Organization,
			&i.Created,
			&i.Uuid,
			&i.Hash,
			&i.Json,
			&i.Deployed,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPipelines = `-- name: ListPipelines :many
SELECT id, organization, created, uuid, hash, json, deployed, deleted FROM Pipelines
WHERE organization = ? AND uuid = ? AND deleted = FALSE
ORDER BY deployed DESC, created DESC
`

type ListPipelinesParams struct {
	Organization string
	Uuid         string
}

func (q *Queries) ListPipelines(ctx context.Context, arg ListPipelinesParams) ([]Pipeline, error) {
	rows, err := q.db.QueryContext(ctx, listPipelines, arg.Organization, arg.Uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pipeline
	for rows.Next() {
		var i Pipeline
		if err := rows.Scan(
			&i.ID,
			&i.Organization,
			&i.Created,
			&i.Uuid,
			&i.Hash,
			&i.Json,
			&i.Deployed,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeletePipeline = `-- name: SoftDeletePipeline :one
UPDATE Pipelines
SET deleted = TRUE, deployed = FALSE
WHERE organization = ? AND uuid = ? AND hash = ?
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type SoftDeletePipelineParams struct {
	Organization string
	Uuid         string
	Hash         string
}

func (q *Queries) SoftDeletePipeline(ctx context.Context, arg SoftDeletePipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, softDeletePipeline, arg.Organization, arg.Uuid, arg.Hash)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}

const undeployPipeline = `-- name: UndeployPipeline :one
UPDATE Pipelines
SET deployed = FALSE
WHERE organization = ? AND uuid = ? AND deployed = TRUE 
RETURNING id, organization, created, uuid, hash, json, deployed, deleted
`

type UndeployPipelineParams struct {
	Organization string
	Uuid         string
}

func (q *Queries) UndeployPipeline(ctx context.Context, arg UndeployPipelineParams) (Pipeline, error) {
	row := q.db.QueryRowContext(ctx, undeployPipeline, arg.Organization, arg.Uuid)
	var i Pipeline
	err := row.Scan(
		&i.ID,
		&i.Organization,
		&i.Created,
		&i.Uuid,
		&i.Hash,
		&i.Json,
		&i.Deployed,
		&i.Deleted,
	)
	return i, err
}
